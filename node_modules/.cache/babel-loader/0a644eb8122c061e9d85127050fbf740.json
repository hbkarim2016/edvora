{"ast":null,"code":"const FilterUpcoming = (originalRidesState, dispatch, rideAdd, pastOrUpcoming) => {\n  const timeNow = new Date();\n  let timeNow_ = timeNow.getTime();\n\n  if (pastOrUpcoming === 'upcoming') {\n    let originalUpcoming = originalRidesState.filter(el => new Date(el.date).getTime() > timeNow_);\n    return dispatch(rideAdd({\n      rides_data: originalUpcoming,\n      upcomingCount: originalUpcoming.length\n    }));\n  } else if (pastOrUpcoming === 'past') {\n    let originalUpcoming = originalRidesState.filter(el => new Date(el.date).getTime() < timeNow_);\n    return dispatch(rideAdd({\n      rides_data: originalUpcoming,\n      pastCount: originalUpcoming.length\n    }));\n  }\n};\n\n_c = FilterUpcoming;\nexport default FilterUpcoming;\n\nvar _c;\n\n$RefreshReg$(_c, \"FilterUpcoming\");","map":{"version":3,"sources":["C:/My Computer/my work/apps/edvora/edvora/src/content/components/Filter/FilterFuncs/FilterUpcoming.jsx"],"names":["FilterUpcoming","originalRidesState","dispatch","rideAdd","pastOrUpcoming","timeNow","Date","timeNow_","getTime","originalUpcoming","filter","el","date","rides_data","upcomingCount","length","pastCount"],"mappings":"AACA,MAAMA,cAAc,GAAG,CAACC,kBAAD,EAAoBC,QAApB,EAA6BC,OAA7B,EAAqCC,cAArC,KAAwD;AAE3E,QAAMC,OAAO,GAAG,IAAIC,IAAJ,EAAhB;AACA,MAAIC,QAAQ,GAAGF,OAAO,CAACG,OAAR,EAAf;;AACA,MAAIJ,cAAc,KAAK,UAAvB,EAAmC;AAC/B,QAAIK,gBAAgB,GAAGR,kBAAkB,CAACS,MAAnB,CAA2BC,EAAE,IAAI,IAAIL,IAAJ,CAASK,EAAE,CAACC,IAAZ,EAAkBJ,OAAlB,KAA8BD,QAA/D,CAAvB;AACA,WAAOL,QAAQ,CAAGC,OAAO,CAAE;AAACU,MAAAA,UAAU,EAACJ,gBAAZ;AAA8BK,MAAAA,aAAa,EAACL,gBAAgB,CAACM;AAA7D,KAAF,CAAV,CAAf;AACH,GAHD,MAGM,IAAIX,cAAc,KAAK,MAAvB,EAA+B;AACjC,QAAIK,gBAAgB,GAAGR,kBAAkB,CAACS,MAAnB,CAA2BC,EAAE,IAAI,IAAIL,IAAJ,CAASK,EAAE,CAACC,IAAZ,EAAkBJ,OAAlB,KAA+BD,QAAhE,CAAvB;AACA,WAAOL,QAAQ,CAAGC,OAAO,CAAE;AAACU,MAAAA,UAAU,EAACJ,gBAAZ;AAA8BO,MAAAA,SAAS,EAACP,gBAAgB,CAACM;AAAzD,KAAF,CAAV,CAAf;AACH;AAEJ,CAZD;;KAAMf,c;AAaN,eAAeA,cAAf","sourcesContent":["\r\nconst FilterUpcoming = (originalRidesState,dispatch,rideAdd,pastOrUpcoming) => {\r\n\r\n    const timeNow = new Date();\r\n    let timeNow_ = timeNow.getTime();\r\n    if( pastOrUpcoming === 'upcoming' ){\r\n        let originalUpcoming = originalRidesState.filter( el => new Date(el.date).getTime() > timeNow_ );\r\n        return dispatch(  rideAdd( {rides_data:originalUpcoming, upcomingCount:originalUpcoming.length } ) );\r\n    }else if( pastOrUpcoming === 'past' ){\r\n        let originalUpcoming = originalRidesState.filter( el => new Date(el.date).getTime() <  timeNow_ );\r\n        return dispatch(  rideAdd( {rides_data:originalUpcoming, pastCount:originalUpcoming.length } ) );\r\n    }\r\n\r\n}\r\nexport default FilterUpcoming;"]},"metadata":{},"sourceType":"module"}